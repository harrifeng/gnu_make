#+OPTIONS: ^:nil
* 概述
* GNU make 介绍
** Makefile简介
   + 以下情况的文件会被重新编译:
     1) 所有源文件都没有被编译过, 则所有都编译生成可执行程序
     2) 每一个上次执行make之后修改过的c源代码文件,本次make的时候会重新编译
     3) 头文件被修改,则所有包含此投文件的c源文件在下次make的时候都会被重新编译
** Mekfile规则介绍
   + 所有Makefile命令都满足如下规则
     #+begin_example
       TARGET...:PREREQUISITES...
       [TAB]COMMAND
     #+end_example
** 简单的示例
   + 最终编译出edit
     #+begin_src makefile
       # sample Makefile
       edit : main.o kdb.o command.o display.o \
              insert.o search.o files.o utils.o
           cc -o edit main.o kdb.o command.o display.o \
                      insert.o search.o files.o utils.o
       main.o : main.c defs.h
           cc -c main.c
       kdb.o : kdb.c defs.h command.h
           cc -c kdb.c
       command.o : command.c defs.h command.h
           cc -c command.c
       display.o :display.c defs.h buffer.h
           cc -c display.c
       insert.o : insert.c defs.h buffer.h
           cc -c insert.c
       serach.o : search.c defs.h buffer.h
           cc -c search.c
       file.o : files.c defs.h buffer.h command.h
           cc -c files.c
       utils.o : utils.c defs.h
           cc -c utils.c
       clean :
           rm edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
     #+end_src
   + 当规则的目标是一个文件的时候, 在它的任何一个依赖文件被修改以后,在执行
     make的时候, 这个目标文件将会被重新编译或者重新连接.
   + 目标clean不是一个五年级,它仅仅代表执行一个动作的标示. 而且目标clean没有
     任何的依赖文件夹,只有一个目的,就是通过这个目标名来执行它所定义的命令. 那么
     *Makefile中把那些没有任何依赖只有执行动作的目标称为"伪目标"(phony targets)*
** Make如何工作
   + 默认情况下make执行的是Makefile中的第一个规则,比如上面例子中就是edit
   + 以上面为例:
     1) 目标的.o文件不存在, 使用其规则创建它们
     2) 目标.o文件存在, 目标.o文件所依赖的.c源文件.h文件中任何一个比.o文件"更新", 
        那就根据规则重新编译它们
     3) 目标.o文件存在, 目标.o文件比它任何一个依赖文件都"更新", 那就什么也不做.
** 指定变量
   + 上面例子的最开始部门,我们可以看到.o文件列表出现了两次, 这个明显的触犯了DRY
     (Don't Repeat Yourself)规则, 这就引入了makefile中的变量概念
     #+begin_src makefile
       ,#+begin_src makefile
       # sample Makefile
       edit : main.o kdb.o command.o display.o \
              insert.o search.o files.o utils.o
           cc -o edit main.o kdb.o command.o display.o \
                 insert.o search.o files.o utils.o
     #+end_src
   + 我们可以改成
     #+begin_src makefile
       objects = main.o kdb.o command.o display.o \
              insert.o search.o files.o utils.o
       edit : $(objects)
           cc -o edit $(objects)
       clean :
           rm edit $(objects)
     #+end_src
** 自动推导规则
   + 既然是计算机,那么自动推导规则(从main.c生成main.o)这个还是能搞定的.
     #+begin_src makefile
       objects = main.o kdb.o command.o display.o \
              insert.o search.o files.o utils.o
       edit : $(objects)
           cc -o edit $(objects)
       main.o : defs.h
       kbd.o : defs.h command.h
       command.o : defs.h command.h
       display.o : defs.h buffer.h
       insert.o : defs.h buffer.h
       search.o : defs.h buffer.h
       files.o : defs.h buffer.h
       utils.o : defs.h
       
       .PHONY : clean
       clean :
           rm edit $(objects)
     #+end_src
** 另类风格的makefile
   + 我们也可以如下创建makefile
     #+begin_src makefile
       objects = main.o kdb.o command.o display.o \
              insert.o search.o files.o utils.o
       edit : $(objects)
           cc -o edit $(objects)
       $(objects):defs.h
       kdb.o command.o files.o : command.h
       display.o insert.o search.o files.o : buffer.h
       
       clean :
           rm edit $(objects)
     #+end_src
   + 但是上面这种风格是不值得推荐的,因为makefile规则的建议原则是*单目标,多依赖*, 
     这样书写会方便后期的维护
** 清除工作目录过程文件
   + 实际应用中,我们要把clean规则如下书写
     #+begin_src makefile
       .PHONY : clean
       # 实践证明-rm是不好使的,还是rm -rf好使
       clean :
           rm -rf edit $(objects)
     #+end_src
* Makefile 总述
** Makefile的内容
   + 一个完整的makefile文件其实也就是包括下面的五个部分:
     1) 显示规则: 描述了如何在多种情况下更新一个或者多个被称之为目标的文件, 书写
        makefile的时候, 需要明确的给出目标文件, 目标的依赖文件列表, 以及更新目标
        文件所需要的命令(也有些规则没有命令, 这样的规则只是纯粹的描述了文件直接的
        依赖关系), 这个规则要求啥都写出来.
     2) 隐含规则:它是make根据一类文件(主要就是文件名后缀)而自动推导出来的规则.make
        根据目标文件名,自动产生目标依赖文件
     3) 变量定义:为了防止DRY, 我们定义了变量
     4) Makefile指示符:
        + 读取文件
        + 决定处理或者忽略Makefile中的某一个特定部分
     5) 注释:也就是#后面的部分
** makefile文件的命名:
   + 默认情况下, make会在工作目录下按照如下文件搜索执行文件: "GNUmakefile", "makefile"
     "Makefile"
   + 如果都没有上面的文件名,那么就是用make -f, make -file来指定读取
** 包含其他makefile文件
   + 首先注意*include后面的文件没有双引号*
   + include告诉make暂停读取当前的Makefile, 转而读取include指定的一个或者多个文件.
     完成以后再继续读取当前Makefile的读取.*这也就意味着B文件在一开始就引用A文件, 
     那么B文件的默认规则不是B文件最开始的规则,而是A的默认规则*
   + FILENAMES支持扩展
     #+begin_src makefile
       include foo *.mk $(bar)
       # 等同于
       include foo a.mk b.mk c.mk bish bash
     #+end_src
   + 通常情况下, include用在下面两个场合:
     1) 有多个不同的程序, 由不同目录下面的几个独立的Makefile来描述其重建规则. 它们
        需要使用一组通用的变量定义. 那就将所有的共同变量放到一个文件lim,然后include
        它们
     2) 当根据文件自动产生依赖文件的时候,我们可以将自动产生的依赖关系保存在另外一个
        文件中, 主Makefile使用指示符"include"包含这些文件. 这样的做法比直接在主
        Makefile中追加依赖文件的方法要明智的多.
** 变量MAKEFILES
   + 如果当前环境定义了环境变量MAKEFILES的话, make会首先将此环境变量的值作为需要读入
     的Makefile文件, 和include区别:
     1) 环境变量指定的makefile中的目标不会被作为make执行的终极目标
     2) 环境变量所定义的文件列表,在执行make时, 如果不能找到其中一个文件, make不会
        提示错误
     3) make在执行时候,首先读取的环境变量"MAKEFILES" 所指的文件列表
   + MAKEFILES很少设置,因为设置会导致混乱, 推荐使用include来实现
** 变量MAKEFILE_LIST
   + make程序在读取多个makefile时候, (包括MAKEFILES指定, include包括的文件),在对
     这些文件进行解析执行之前make读取的文件名将会被自动追加到变量MAKEFILE_LIST的定义
     域中. 所以我们可以通过对MAKEFILE_LIST进行处理来取得当前文件名
     #+begin_src makefile
       name1 := $(word $(words $(MAKEFILE_LIST)), $(MAKEFILE_LIST))
       # some file in current folder, called inc.mk
       include inc.mk
       name2 := $(word $(words $(MAKEFILE_LIST)), $(MAKEFILE_LIST))
       
       all:
           @echo name1 = $(name1)
           @echo name2 = $(name2)
       
       #---------output---------
       # name1 = Makefile
       # name2 = inc.mk    
     #+end_src
** 其他特殊变量
   + GNU make支持一个特殊的变量".VARIABLES", 他不能通过其他途径给予赋值, 展开以后
     他的值是在这个变量引用之前的,所有定义的全局变量的列表
** makefile文件的重建
   + 存疑
** 重载另外一个makefile
   + 有些情况下,makefile-A需要使用另外一个makefile-B中所定义的变量和规则. 最简单
     的做法,当然是在makefile-A中include文件makefile-B, 但是使用这种方法,如果两
     个makefile文件中村咋相同的目标(而规则不同),那么就会与make的要求想左.
   + 为了解决上述问题,可以使用make中的"%"匹配所有规则的方法,如下:
     #+begin_src makefile
       #sample GNUmakefile
       foo:
           frobnicate > foo
       %:force
           @$(MAKE) -f Makefile $@
       force:;
     #+end_src
   + 上面例子是GUNmake文件的内容, 如果我们make foo, 那么就会自动执行 frobnicate,
     如果我们执行make bar, 当前文件下没有bar这个目标,那么就会对应到"%", 也就是会
     去make -f Makefile, 也就是去Makefile文件里面找bar.
   + 如果Makefile里面有foo目标了怎么办? 没事,因为那样的话就不会去读取Makefile了
   + 如果细心观察会发现%(所有模式匹配规则)还依赖了一个force: 这样保证了及时目标文件
     已经存在(比如bar已经存在了), 依然还是会去执行这个规则(因为依赖force是新的, 就
     必须重新执行).
   + 而force规则则只使用了空命令: 这是为了防止make试图寻找一个规则去创建force的时候,
     又引用了%:force而陷入无限循环.
** make如何解析makefile文件
   + GUN make的执行分为两个阶段:
     1) 读取所有的makefile文件(包括MAKIFILES指定;include指定;命令行-f指定的makefile
        文件). 内建所有的变量, 明确规则,隐含规则. 并建立所有的目标和依赖之间的依赖关系
        链表
     2) 根据第一阶段建立的依赖关系链表决定哪些目标需要更新, 并使用对应的规则来重新创建
        这些目标
*** 变量取值
    + 变量定义规则有如下:
      #+begin_src makefile
        IMMEDIATE = DEFERRED
        IMMEDIATE ?= DEFERRED
        IMMEDIATE := IMMEDIATE
        IMMEDIATE += DEFERRED or IMMEDIATE
        define IMMEDIATE
            DEFERRED
        endef
      #+end_src
    + 如果一个变量使用了+=时候, 如果此前这个变量是一个简单变量(使用:=定义的), 则认为
      它是立即展开的,其他情况则都认为是"延后"展开的变量
*** 条件语句
    + 条件语句都是立即展开的,包括ifdef, ifeq, ifndef, ifneq
*** 规则的定义
    + 所有规则在执行make时, 都按照如下模式展开:
      #+begin_src makefile
        IMMEDIATE : IMMEDIATE; DEFERRED
            DEFERRED
      #+end_src
    + 规则中目标和依赖如果引用其他变量, 则立即展开. 而规则的命令行中的变量则会被延后展开
** 总结
   + make的执行过程如下:
     1) 一次读取变量MAKEFILES定义的makefile文件列表
     2) 读取工作目录下的makefile文件(根据命名的查找顺序"GNUmakefile", "makefile", 
        "Makefile", 首先找到哪个就读取哪个)
     3) 依次读取工作目录makefile文件中使用指示符include包含的文件
     4) 查找重建所有已读的makefile文件规则
     5) 初始化变量值并展开那些需要立即展开的变量和还是冰根据预设条件确定执行分支
     6) 根据"终极目标"以及其他目标的依赖关系简历依赖关系链表
     7) 执行"终极目标"以外的所有的目标的规则（根据目标文件和所有依赖文件的时间戳).
     8) 执行"终极目标＂所在的规则
* Makefile的规则
** 一个例子
   + 下面我们看一个规则的例子
     #+begin_src makefile
       foo.o : foo.c defs.h      #module for twiddling the frobs
           cc -c -g foo.c
     #+end_src
   + foo.o是要重建的文件(目标), foo.c 和 defs.h是重建foo.o所需要使用的文件(依赖).
** 规则语法
   + 通常的语法规则如下:
     #+begin_src makefile
       TARGETS : PREREQUISITES
           COMMAND
     #+end_src
   + 或者可以如下(命令在分号后面)
     #+begin_src makefile
       TARGET : PREREQUISITES ; COMMAND
           COMMAND
     #+end_src
   + TARGETS可以是文件名(推荐只有一个文件名,虽然多个也可以), 或者是一个标签(比如
     clean). TARGETS文件名可以用通配符
   + 书写规则有如下注意事项:
     1) 如果不是在分号后面加命令,而是要另起一行的话, [TAB]必须顶头
     2) Makefile中的的符合"$"有特殊含义, 规则中需要使用"$"的地方,要用"$$"代替
     3) 长度过长要用反斜杠"\"加到独立行之间.
** 依赖的类型
   + 常规的依赖我们就不说了,目标后面的依赖只要有一个时间戳近,那就一定要重新执行
   + 如果我们有些依赖不希望更新那么频繁,即便它更新了,我们也不想就此判断目标需要
     重新执行,那么我们就要用到order-only依赖, 其实就是利用管道符号(|), 管道
     后面的依赖更新不更新和目标重做不重做就没有关系了.
     #+begin_src makefile
       LIBS = libtest.a
       foo : foo.c | $(LIBS)
           $(CC) $(CFLAGS) $< -o $@ $(LIBS)
     #+end_src
** 文件名使用通配符
   + Makefile中的直接使用文件通配符(规则和bash shell一致)的情况有两种:
     1) 在规则,依赖中使用, 会在make读取makefile的时候就展开
     2) 在命令中使用,通配符会在shell执行命令的时候完成
   + 除此之外,其他上下文中都要使用函数wildcard来实现通配
*** 通配符使用举例
    + 变量定义中"object = *.o"不是表示objects代表所有.o文件, 这种情况
      需要使用"object = $(wildcar *.o)
*** 通配符存在的缺陷
    + 我们要时刻牢记通配符仅仅适合在[目标,依赖,命令]中*直接*出现, 即便变量定义了
      通配符是为[目标,依赖,命令]服务的,也常常会造成奇怪的现象,比如:
      #+begin_src makefile
        objects = *.o
        
        foo :＄(objects)
            cc =o foo $(CFLAGS) $(objects)
      #+end_src
    + 这个objects因为是为依赖服务的,所以如果当前文件夹下原来有*.o文件,那么不会报错,
      因为依赖会成功匹配当前文件夹下的所有*.o文件. 但是如果make clean 去掉.o文件,
      或者你加一个fake.o,那么make就晕了,再次的make就会引发如下错误
      #+begin_src sh
        fake.o: file not recognized: File truncated
        collect2: ld returned 1 exit status
        Makefile:5: recipe for target `edit' failed
        make: *** [edit] Error 1
      #+end_src
*** 函数wildcard
    + 解决办法当然就是wildcard啦, 需要注意的是wildcard如果找不到合适的匹配,会忽略
      模式字符,直接返回空.上面例子的解决方法如下
      #+begin_src makefile
        # sample Makefile
        objects := $(patsubst %.c, %.o, $(wildcard *.c))
        
        foo : $(objects)
            cc -o foo $(objects)
      #+end_src
    + 需要注意的是,这里的定义是用的":=", 我们现在只要知道用了函数wildcard,那么就
      推荐使用":=", 因为这个会减少递归调用的风险

      
      

     






        


     

